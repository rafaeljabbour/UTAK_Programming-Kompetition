<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Fire Rescue App Demo (Safe Havens + Fire Blocking)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Mapbox GL JS -->
  <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <link href="https://api.tiles.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />

  <!-- Mapbox GL Directions Plugin -->
  <script
    src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.1/mapbox-gl-directions.js"></script>
  <link rel="stylesheet"
    href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.1.1/mapbox-gl-directions.css"
    type="text/css" />

  <!-- Turf.js for geometry operations (buffer, intersection, etc.) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }

    /* Map container covers the full screen */
    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }

    /* Container for our custom UI buttons/inputs */
    .ui-container {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 6px;
      padding: 16px;
      z-index: 2;
      /* Ensure it sits above the map */
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      width: 220px;
    }

    .ui-container h1 {
      margin: 0 0 1em 0;
      font-size: 1.2em;
      text-align: center;
    }

    .ui-button,
    .ui-input {
      display: block;
      width: 100%;
      margin: 0.5em 0;
      padding: 0.4em 0.6em;
      font-size: 1em;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    .ui-button {
      cursor: pointer;
      background-color: #f8f8f8;
      transition: background-color 0.2s;
    }

    .ui-button:hover {
      background-color: #eee;
    }

    /* Optional: Keep the top-left Mapbox controls nicely spaced. */
    .mapboxgl-ctrl-top-left {
      margin-top: 10px;
      margin-left: 10px;
    }
  </style>
</head>

<body>
  <!-- The map -->
  <div id="map"></div>

  <!-- Custom UI Container -->
  <div class="ui-container">
    <h1>Fire Rescue</h1>

    <!-- Toggle Fire Mode -->
    <button id="toggleBlockBtn" class="ui-button">Enable Fire Mode</button>

    <!-- Destination input (optional override) -->
    <input id="destinationInput" class="ui-input" type="text" placeholder="Address or Lat,Lng..." />
    <button id="setDestBtn" class="ui-button">Set Destination</button>

    <!-- Focus user location -->
    <button id="focusMeBtn" class="ui-button">Focus on Me</button>
  </div>

  <script>
    // --------------------------------------------------
    // 1) BASIC MAP & DIRECTIONS SETUP
    // --------------------------------------------------
    mapboxgl.accessToken =
      'pk.eyJ1IjoicmFsZHV0ZWsiLCJhIjoiY202MmR5MDViMHlmMjJucG5mcWw4emo4ZSJ9.Ox0uAsJ9O66fBpsEUOMXlw';

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [-79.38, 43.65], // Default: Toronto
      zoom: 12
    });

    // Basic map controls
    map.addControl(new mapboxgl.NavigationControl(), 'top-left');
    map.addControl(
      new mapboxgl.ScaleControl({ maxWidth: 100, unit: 'metric' }),
      'bottom-left'
    );

    // Directions plugin, set interactive=false so clicks don't change routes automatically
    const directions = new MapboxDirections({
      accessToken: mapboxgl.accessToken,
      unit: 'metric',
      profile: 'mapbox/driving',
      interactive: false,
      controls: {
        inputs: false,
        instructions: true
      }
    });
    map.addControl(directions, 'top-left');

    // Optional bounding box
    const bounds = [
      [-80, 43],   // Southwest corner
      [-78.5, 44]  // Northeast corner
    ];
    map.setMaxBounds(bounds);


    // --------------------------------------------------
    // 2) USER LOCATION
    // --------------------------------------------------
    let userLocation = null;  // [lng, lat]
    let userMarker = null;

    // Start watching user's location
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        (pos) => {
          userLocation = [pos.coords.longitude, pos.coords.latitude];

          // Create or update the user marker
          if (!userMarker) {
            userMarker = new mapboxgl.Marker({ color: 'blue' })
              .setLngLat(userLocation)
              .addTo(map);
          } else {
            userMarker.setLngLat(userLocation);
          }

          // Recalculate route to best safe haven (unless user overrides with Destination Input)
          if (!customDestinationActive) {
            recalcRouteToBestSafeHaven();
          }
        },
        (err) => {
          console.error('Geolocation error:', err);
          alert('Unable to retrieve your location. Showing default center (Toronto).');
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    } else {
      alert('Geolocation is not supported by your browser.');
    }

    // "Focus on Me" button
    const focusMeBtn = document.getElementById('focusMeBtn');
    focusMeBtn.addEventListener('click', () => {
      if (userLocation) {
        map.flyTo({ center: userLocation, zoom: 14 });
      } else {
        alert('User location not available yet.');
      }
    });


    // --------------------------------------------------
    // 3) SAFE HAVENS (3 locations, marked in yellow)
    // --------------------------------------------------
    const safeHavens = [
      { name: 'Haven A', coords: [-79.36, 43.65] },
      { name: 'Haven B', coords: [-79.40, 43.66] },
      { name: 'Haven C', coords: [-79.35, 43.63] },
    ];

    // Place the safe haven markers
    safeHavens.forEach((haven) => {
      new mapboxgl.Marker({ color: 'yellow' })
        .setLngLat(haven.coords)
        .setPopup(new mapboxgl.Popup().setText(haven.name))
        .addTo(map);
    });


    // --------------------------------------------------
    // 4) FIRE MODE (ROAD BLOCK MODE)
    // --------------------------------------------------
    let fireMode = false; // "roadBlockMode"
    const toggleBlockBtn = document.getElementById('toggleBlockBtn');
    toggleBlockBtn.addEventListener('click', () => {
      fireMode = !fireMode;
      toggleBlockBtn.textContent = fireMode
        ? 'Disable Fire Mode'
        : 'Enable Fire Mode';
    });

    // We'll store an array of "fire points" plus their buffer polygons
    let fireFeatures = [];
    let fireBuffers = []; // Polygons from turf.buffer

    // On map click, if Fire Mode is ON, place a "fire marker" and recalc routes
    map.on('click', (event) => {
      if (!fireMode) return;

      // 1) Place a red marker to represent fire
      new mapboxgl.Marker({ color: 'red' })
        .setLngLat(event.lngLat)
        .addTo(map);

      // 2) Buffer ~20m around the fire point
      const firePoint = turf.point([event.lngLat.lng, event.lngLat.lat]);
      const bufferPoly = turf.buffer(firePoint, 0.02, { units: 'kilometers' });

      fireFeatures.push(firePoint);
      fireBuffers.push(bufferPoly);

      // 3) Recalculate route if user is not using a custom destination
      if (!customDestinationActive) {
        recalcRouteToBestSafeHaven();
      }
    });


    // --------------------------------------------------
    // 5) CALCULATE BEST ROUTE TO ANY SAFE HAVEN
    // --------------------------------------------------
    // We do a custom request to the Mapbox Directions API for each haven, 
    // check if the route intersects any fire buffers, and pick the best non-blocked route.
    async function recalcRouteToBestSafeHaven() {
      if (!userLocation) return;

      // We'll gather route info for each safe haven
      let candidateRoutes = [];

      for (const haven of safeHavens) {
        const routeData = await fetchRoute(userLocation, haven.coords);
        if (!routeData) continue;

        const route = routeData.routes?.[0];
        if (!route) continue;

        // Convert route geometry to a turf linestring
        const routeCoords = route.geometry.coordinates;
        const routeLine = turf.lineString(routeCoords);

        // Check if route intersects any fire buffers
        const isBlocked = fireBuffers.some((poly) => {
          return turf.booleanIntersects(routeLine, poly);
        });

        candidateRoutes.push({
          haven,
          isBlocked,
          distance: route.distance,   // meters
          duration: route.duration,   // seconds
        });
      }

      if (!candidateRoutes.length) {
        console.warn('No routes found to any haven (maybe no user location?).');
        return;
      }

      // Filter out blocked routes
      const nonBlocked = candidateRoutes.filter((r) => !r.isBlocked);
      let bestRoute = null;

      if (!nonBlocked.length) {
        // All are blocked
        bestRoute = candidateRoutes.sort((a, b) => a.distance - b.distance)[0];
        alert('All safe havens are blocked by fire! Showing the shortest anyway.');
      } else {
        // Among non-blocked, pick the shortest
        bestRoute = nonBlocked.sort((a, b) => a.distance - b.distance)[0];
      }

      // Set directions plugin to that haven
      directions.setOrigin(userLocation);
      directions.setDestination(bestRoute.haven.coords);
    }

    // Helper: Fetch route from Mapbox Directions API
    async function fetchRoute(from, to) {
      const url = `https://api.mapbox.com/directions/v5/mapbox/driving/` +
        `${from[0]},${from[1]};${to[0]},${to[1]}` +
        `?geometries=geojson&overview=full&access_token=${mapboxgl.accessToken}`;
      try {
        const resp = await fetch(url);
        if (!resp.ok) {
          console.error('Error fetching route:', resp.status, resp.statusText);
          return null;
        }
        return await resp.json();
      } catch (err) {
        console.error('Request failed:', err);
        return null;
      }
    }


    // --------------------------------------------------
    // 6) DESTINATION INPUT (OPTIONAL OVERRIDE)
    // --------------------------------------------------
    let customDestinationActive = false; // if user sets a custom address

    const destinationInput = document.getElementById('destinationInput');
    const setDestBtn = document.getElementById('setDestBtn');

    setDestBtn.addEventListener('click', () => {
      const inputValue = destinationInput.value.trim();
      if (!inputValue) {
        alert('Please enter a destination (address or lat,lng).');
        return;
      }
      customDestinationActive = true;

      // If user enters lat,lng or lng,lat, parse it
      const coords = inputValue.split(',');
      if (coords.length === 2) {
        const lat = parseFloat(coords[0]);
        const lng = parseFloat(coords[1]);
        if (!isNaN(lat) && !isNaN(lng)) {
          // We'll assume "lat,lng" format. Swap if you prefer "lng,lat".
          directions.setDestination([lng, lat]);
          return;
        }
      }
      // Otherwise, treat as an address or place name
      directions.setDestination(inputValue);
    });
  </script>
</body>

</html>